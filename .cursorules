# Strategy Project - Cursor Rules

## General Principles

### Pure Functions & Test Coverage
- **ALWAYS** write pure functions when possible (no side effects, same input = same output)
- **EVERY** function must have corresponding unit tests with minimum 80% coverage
- Functions should be small, focused, and do one thing well
- Avoid mutations - prefer immutability and return new values
- Test edge cases, error handling, and happy paths

### Code Quality
- Write self-documenting code with clear variable and function names
- Keep functions small (max 20-30 lines)
- Use TypeScript strictly - avoid `any` types
- Follow SOLID principles
- DRY (Don't Repeat Yourself) - extract common logic

## Frontend Architecture (Vue 3) - MODULE-BASED

### Module-Based Structure - STRICT ENFORCEMENT

The frontend MUST follow a **module-based architecture** where each feature/module is self-contained with its own layers:

```
src/
└── modules/
    └── auth/                    # Example: Auth Module
        ├── api/                 # API service layer (HTTP calls)
        │   └── authApi.ts
        ├── services/            # Business logic services
        │   └── authService.ts
        ├── stores/              # Pinia stores (state management)
        │   └── authStore.ts
        ├── views/               # Page-level components
        │   ├── LoginView.vue
        │   └── RegisterView.vue
        └── components/          # Module-specific components
            ├── LoginForm.vue
            └── RegisterForm.vue
```

### Module Structure Rules

**EVERY module MUST have:**
- `api/` - API service layer (HTTP requests only)
- `services/` - Business logic services (optional, for complex logic)
- `stores/` - State management (Pinia stores)
- `views/` - Page-level components
- `components/` - Module-specific UI components

### Layer Separation - STRICT ENFORCEMENT

Each module follows a strict 3-layer architecture:

```
┌─────────────────────────────────────┐
│    Module Views/Components          │  ← Presentation Layer
│  (Consume Store & Service)          │
└──────────────┬──────────────────────┘
               │
       ┌───────┴────────┐
       │                │
┌──────▼──────┐  ┌──────▼──────┐
│   Store     │  │   API       │
│  (State)    │  │   (HTTP)    │
└─────────────┘  └──────┬──────┘
                        │
                        │
                ┌───────▼──────┐
                │   Backend    │
                │     API      │
                └──────────────┘
```

### 1. API Layer (`modules/{module}/api/`)
- **Purpose**: Handle ALL API calls and external data fetching
- **Rules**:
  - API files are pure functions/classes that only make HTTP requests
  - NO state management in API layer
  - API functions return promises/data, never directly update UI or state
  - Each API function should have corresponding unit tests
  - API functions should handle errors and throw meaningful exceptions
  - Use TypeScript interfaces for request/response types
  - One API file per module

**Example Structure:**
```typescript
// modules/auth/api/authApi.ts
export const authApi = {
  async login(credentials: LoginRequest): Promise<LoginResponse> {
    // Only API calls, no state updates
  },
  async register(data: RegisterRequest): Promise<RegisterResponse> {
    // Only API calls
  }
}
```

### 2. Service Layer (`modules/{module}/services/`) - REQUIRED
- **Purpose**: Handle ALL async operations and business logic
- **Rules**:
  - Services handle ALL async operations (API calls, data fetching)
  - Services are instantiated with the store: `new Service(store)` or `class Service { private store = useStore() }`
  - Services import API layer to call backend
  - Services use store to update state management (call store's sync actions)
  - Services contain business logic and orchestration
  - NO state management in services - only call store actions
  - Each service method should have unit tests
  - Export a singleton instance: `export const service = new Service()`

**Example Structure:**
```typescript
// modules/auth/services/authService.ts
import { authApi } from '../api/authApi'
import { useAuthStore } from '../stores/authStore'

class AuthService {
  private store = useAuthStore()

  async login(credentials: LoginRequest): Promise<void> {
    this.store.setLoading(true)
    this.store.setError(null)
    
    try {
      const response = await authApi.login(credentials) // Call API
      this.store.setToken(response.access_token) // Update store
      this.store.setUser(response.user) // Update store
    } catch (err) {
      this.store.setError(err.message)
      throw err
    } finally {
      this.store.setLoading(false)
    }
  }
}

export const authService = new AuthService()
```

### 3. Store Layer (`modules/{module}/stores/`)
- **Purpose**: Manage module-specific state (SYNCHRONOUS ONLY)
- **Rules**:
  - Stores handle ALL state mutations for the module
  - Stores ONLY have SYNCHRONOUS actions (setters, state updates)
  - NO async operations in stores (no async/await)
  - NO API calls from stores (must go through Service layer)
  - Stores expose reactive state, computed properties, and sync actions
  - Store actions are pure functions that update state
  - Stores must have unit tests for all actions and state changes
  - One store file per module (or multiple if module is large)

**Example Structure:**
```typescript
// modules/auth/stores/authStore.ts
export const useAuthStore = defineStore('auth', () => {
  const user = ref<User | null>(null)
  const token = ref<string | null>(null)
  const loading = ref(false)
  const error = ref<string | null>(null)

  const isAuthenticated = computed(() => !!token.value && !!user.value)

  // Synchronous actions only
  function setToken(newToken: string | null): void {
    token.value = newToken
  }

  function setUser(newUser: User | null): void {
    user.value = newUser
  }

  function setLoading(isLoading: boolean): void {
    loading.value = isLoading
  }

  function setError(errorMessage: string | null): void {
    error.value = errorMessage
  }

  return { user, token, loading, error, isAuthenticated, setToken, setUser, setLoading, setError }
})
```

### 4. Views Layer (`modules/{module}/views/`)
- **Purpose**: Page-level components for the module
- **Rules**:
  - Views are route-level components
  - Views consume stores for state (read-only)
  - Views call SERVICE methods, NOT store actions directly for async operations
  - Views can call store sync actions only for simple state updates
  - Views should be straightforward and easy to understand
  - NO business logic in views - delegate to services
  - Use composition API with `<script setup>`
  - Each view should have unit tests

**Example Structure:**
```vue
<!-- modules/auth/views/LoginView.vue -->
<script setup lang="ts">
import { useAuthStore } from '../stores/authStore'
import { authService } from '../services/authService'
import LoginForm from '../components/LoginForm.vue'

const authStore = useAuthStore()

// View calls service for async operations
const handleLogin = async () => {
  await authService.login(credentials)
}
</script>

<template>
  <LoginForm @submit="handleLogin" />
</template>
```

### 5. Components Layer (`modules/{module}/components/`)
- **Purpose**: Module-specific UI components
- **Rules**:
  - Components should be SMALL and focused (max 200-300 lines)
  - Split large components into smaller, reusable components
  - Components consume stores for state (read-only)
  - Components call SERVICE methods for async operations, NOT store actions
  - Components can call store sync actions for simple state updates
  - Components should be straightforward and easy to understand
  - NO business logic in components - delegate to services
  - Use composition API with `<script setup>`
  - Each component should have unit tests

**Example Structure:**
```vue
<!-- modules/auth/components/LoginForm.vue -->
<script setup lang="ts">
import { useAuthStore } from '../stores/authStore'
import { authService } from '../services/authService'

const authStore = useAuthStore()

// Component calls service for async operations
const handleSubmit = async () => {
  await authService.login(credentials)
}
</script>

<template>
  <!-- Simple, straightforward template -->
</template>
```

### Component Splitting Rules
- If a component exceeds 300 lines, split it
- Extract reusable logic into composables (`src/composables/`)
- One component = one responsibility
- Use props and emits for parent-child communication
- Use stores for shared state across components

### Data Flow Pattern (Module-Based)
```
User Action → Component/View → Service → API Layer → Backend API
                                      ↓
                                   Service calls Store (sync actions)
                                      ↓
                                   Store updates State
                                      ↓
                                   UI Reacts
```

**NEVER:**
- ❌ Call API directly from components/views
- ❌ Call API directly from stores
- ❌ Put async operations in stores
- ❌ Update state directly in components/views (except simple sync updates)
- ❌ Put business logic in components/views
- ❌ Make HTTP calls from stores
- ❌ Mix state management with API calls
- ❌ Create modules without proper structure (api/services/stores/views/components)

**ALWAYS:**
- ✅ Components/Views → Service → API Layer → Backend
- ✅ Service → Store (sync actions) → State updates
- ✅ Keep components simple and presentational
- ✅ Keep stores focused on synchronous state management only
- ✅ Keep services focused on async operations and business logic
- ✅ Keep API layer focused on HTTP requests
- ✅ Organize code by modules, not by technical layers
- ✅ Each module must have: api/, services/, stores/, views/, components/

## Backend Architecture (NestJS) - MODULE-BASED

### Module-Based Structure - STRICT ENFORCEMENT

The backend MUST follow a **module-based architecture** where each feature/module is self-contained:

```
src/
└── modules/
    └── auth/                    # Example: Auth Module
        ├── auth.controller.ts   # HTTP endpoints
        ├── auth.service.ts      # Business logic
        ├── auth.module.ts       # Module definition
        ├── dto/                 # Data Transfer Objects
        │   ├── login.dto.ts
        │   └── register.dto.ts
        ├── entities/            # Database entities (if using ORM)
        │   └── user.entity.ts
        ├── guards/              # Route guards
        │   └── jwt-auth.guard.ts
        └── strategies/          # Auth strategies (Passport)
            └── jwt.strategy.ts
```

### Module Structure Rules

**EVERY module MUST have:**
- `{module}.controller.ts` - HTTP endpoints
- `{module}.service.ts` - Business logic
- `{module}.module.ts` - Module definition
- `dto/` - Data Transfer Objects for validation
- Optional: `entities/`, `guards/`, `strategies/`, `interceptors/`

### Pure Functions
- Write pure functions for business logic
- Separate controllers, services, and repositories
- Controllers handle HTTP, services handle business logic
- Use dependency injection
- Each service method should have unit tests
- Use decorators for route protection (`@Public()`, `@UseGuards()`)

### Route Protection
- Use `@Public()` decorator for public routes
- Use `@UseGuards(JwtAuthGuard)` for protected routes
- Create custom guards per module if needed
- Implement JWT authentication with Passport

### Testing Requirements
- Unit tests for all services and utilities
- Integration tests for API endpoints
- Minimum 80% code coverage
- Test error cases and edge conditions
- Test both public and protected routes

## API Design Best Practices

### RESTful API Principles

#### 1. Resource-Based URLs
- Use nouns, not verbs in URLs
- Use plural nouns for collections
- Use hierarchical structure for nested resources
- Keep URLs simple and intuitive

**✅ GOOD:**
```
GET    /api/users
GET    /api/users/:id
POST   /api/users
PUT    /api/users/:id
DELETE /api/users/:id
GET    /api/users/:id/posts
```

**❌ BAD:**
```
GET    /api/getUsers
POST   /api/createUser
GET    /api/user/:id/getPosts
```

#### 2. HTTP Methods
- **GET** - Retrieve resources (idempotent, safe)
- **POST** - Create new resources
- **PUT** - Update entire resource (idempotent)
- **PATCH** - Partial update (idempotent)
- **DELETE** - Remove resources (idempotent)

**Rules:**
- Use appropriate HTTP methods for operations
- GET requests should never modify data
- POST for creating, PUT/PATCH for updating
- DELETE for removal

#### 3. HTTP Status Codes
Use appropriate status codes consistently:

**Success (2xx):**
- `200 OK` - Successful GET, PUT, PATCH
- `201 Created` - Successful POST (resource created)
- `204 No Content` - Successful DELETE

**Client Error (4xx):**
- `400 Bad Request` - Invalid request syntax/validation
- `401 Unauthorized` - Authentication required
- `403 Forbidden` - Authenticated but not authorized
- `404 Not Found` - Resource doesn't exist
- `409 Conflict` - Resource conflict (e.g., duplicate email)
- `422 Unprocessable Entity` - Validation errors

**Server Error (5xx):**
- `500 Internal Server Error` - Generic server error
- `502 Bad Gateway` - Invalid response from upstream
- `503 Service Unavailable` - Service temporarily unavailable

#### 4. Request/Response Format

**Request Headers:**
- Always include `Content-Type: application/json`
- Include `Authorization: Bearer <token>` for protected routes
- Use appropriate `Accept` headers

**Request Body:**
- Use JSON format
- Validate all inputs with DTOs
- Include only necessary fields

**Response Format:**
```typescript
// Success Response
{
  "data": { ... },           // Single resource or array
  "message": "Success",      // Optional message
  "meta": {                  // Optional metadata
    "total": 100,
    "page": 1,
    "limit": 10
  }
}

// Error Response
{
  "statusCode": 400,
  "message": "Validation failed",
  "error": "Bad Request",
  "errors": [                // Validation errors
    {
      "field": "email",
      "message": "Email is required"
    }
  ]
}
```

#### 5. Pagination
Always paginate list endpoints:

**Query Parameters:**
- `page` - Page number (default: 1)
- `limit` - Items per page (default: 10, max: 100)
- `sort` - Sort field (e.g., `createdAt`)
- `order` - Sort order (`asc` or `desc`)

**Response:**
```typescript
{
  "data": [...],
  "meta": {
    "page": 1,
    "limit": 10,
    "total": 100,
    "totalPages": 10,
    "hasNext": true,
    "hasPrev": false
  }
}
```

#### 6. Filtering and Searching
Use query parameters for filtering:

**✅ GOOD:**
```
GET /api/users?status=active&role=admin
GET /api/users?search=john&sort=name&order=asc
GET /api/posts?category=tech&tags=javascript,typescript
```

**❌ BAD:**
```
GET /api/users/filter/active/admin
GET /api/searchUsers?q=john
```

#### 7. Error Handling

**Consistent Error Response:**
```typescript
{
  "statusCode": 400,
  "message": "Error message",
  "error": "Error type",
  "timestamp": "2024-01-01T00:00:00.000Z",
  "path": "/api/users"
}
```

**Validation Errors:**
```typescript
{
  "statusCode": 422,
  "message": "Validation failed",
  "errors": [
    {
      "field": "email",
      "message": "Email must be a valid email address",
      "value": "invalid-email"
    }
  ]
}
```

**Rules:**
- Always return consistent error format
- Include helpful error messages
- Don't expose sensitive information (stack traces in production)
- Use appropriate HTTP status codes
- Log errors server-side for debugging

#### 8. Versioning
Use URL versioning for API:

**✅ GOOD:**
```
/api/v1/users
/api/v2/users
```

**Implementation:**
```typescript
@Controller('v1/users')  // Version in controller
// or
app.setGlobalPrefix('api/v1')  // Global version prefix
```

#### 9. Security Best Practices

**Authentication & Authorization:**
- Use JWT tokens for authentication
- Implement token refresh mechanism
- Use HTTPS in production
- Validate and sanitize all inputs
- Use rate limiting to prevent abuse
- Implement CORS properly

**Data Protection:**
- Never expose sensitive data (passwords, tokens, keys)
- Hash passwords (bcrypt, argon2)
- Use parameterized queries to prevent SQL injection
- Validate file uploads (type, size, content)
- Sanitize user inputs

**Headers:**
- Set security headers (CORS, CSP, X-Frame-Options)
- Use secure cookies if using cookie-based auth
- Implement CSRF protection

#### 10. DTOs and Validation

**Always use DTOs:**
```typescript
// dto/create-user.dto.ts
import { IsEmail, IsString, MinLength, IsOptional } from 'class-validator'

export class CreateUserDto {
  @IsEmail()
  @IsNotEmpty()
  email: string

  @IsString()
  @MinLength(6)
  password: string

  @IsString()
  @IsOptional()
  name?: string
}
```

**Validation Rules:**
- Validate all inputs with class-validator
- Use appropriate decorators (`@IsEmail()`, `@MinLength()`, etc.)
- Return clear validation error messages
- Validate nested objects
- Use custom validators for complex validation

#### 11. API Documentation

**Use Swagger/OpenAPI:**
```typescript
import { ApiTags, ApiOperation, ApiResponse } from '@nestjs/swagger'

@ApiTags('users')
@Controller('users')
export class UsersController {
  @ApiOperation({ summary: 'Create a new user' })
  @ApiResponse({ status: 201, description: 'User created successfully' })
  @ApiResponse({ status: 400, description: 'Bad request' })
  @Post()
  create(@Body() createUserDto: CreateUserDto) {
    // ...
  }
}
```

**Documentation Requirements:**
- Document all endpoints
- Include request/response examples
- Document error responses
- Include authentication requirements
- Document query parameters and filters

#### 12. Performance Optimization

**Caching:**
- Cache frequently accessed data
- Use appropriate cache headers
- Implement cache invalidation
- Cache at appropriate levels (Redis, in-memory)

**Database:**
- Use indexes for frequently queried fields
- Implement pagination for large datasets
- Use eager/lazy loading appropriately
- Optimize queries (avoid N+1 problems)
- Use database connection pooling

**Response Optimization:**
- Return only necessary fields
- Use field selection/projection
- Compress responses (gzip)
- Implement response caching

#### 13. API Naming Conventions

**Endpoints:**
- Use lowercase with hyphens: `/api/user-profiles`
- Be consistent across the API
- Use clear, descriptive names

**Query Parameters:**
- Use camelCase: `?sortBy=createdAt&orderBy=desc`
- Be consistent with naming

**Response Fields:**
- Use camelCase: `{ "firstName": "John", "createdAt": "..." }`
- Be consistent across all responses

#### 14. Idempotency

**Make operations idempotent:**
- GET, PUT, DELETE should be idempotent
- Use idempotency keys for POST operations when needed
- Return same result for same input

**Example:**
```typescript
// Idempotent PUT
PUT /api/users/:id
// Same request multiple times = same result

// Idempotent POST with key
POST /api/orders
Headers: { "Idempotency-Key": "unique-key" }
// Same key = same result, no duplicate creation
```

#### 15. API Response Time

**Performance Targets:**
- Simple queries: < 100ms
- Complex queries: < 500ms
- Database operations: < 1s
- File uploads: Depends on size

**Monitoring:**
- Log response times
- Set up alerts for slow endpoints
- Monitor database query performance
- Track API usage and patterns

### API Design Checklist

Before deploying an API endpoint, ensure:
- [ ] Uses appropriate HTTP method
- [ ] Returns correct HTTP status codes
- [ ] Has proper error handling
- [ ] Validates all inputs with DTOs
- [ ] Is protected with authentication/authorization if needed
- [ ] Has proper documentation (Swagger)
- [ ] Follows RESTful conventions
- [ ] Returns consistent response format
- [ ] Implements pagination for list endpoints
- [ ] Has proper error messages
- [ ] Doesn't expose sensitive information
- [ ] Has unit and integration tests
- [ ] Is performant (meets response time targets)
- [ ] Is versioned appropriately

## File Organization

### Frontend Structure - MODULE-BASED
```
src/
├── modules/                    # Feature modules (MODULE-BASED)
│   ├── auth/                  # Auth module
│   │   ├── api/              # API layer
│   │   ├── services/         # Business logic (optional)
│   │   ├── stores/           # State management
│   │   ├── views/            # Page components
│   │   └── components/       # Module components
│   ├── user/                 # User module
│   │   ├── api/
│   │   ├── stores/
│   │   ├── views/
│   │   └── components/
│   └── ...                   # Other modules
├── shared/                    # Shared across modules
│   ├── components/           # Shared UI components (Button, Input, etc.)
│   ├── composables/          # Reusable composition functions
│   ├── types/                # Shared TypeScript types
│   ├── utils/                # Pure utility functions
│   └── constants/            # Shared constants
└── __tests__/                # Global test utilities
```

### Module Naming
- Modules: lowercase, singular (e.g., `auth`, `user`, `product`)
- Each module is self-contained and independent

### Naming Conventions
- Modules: lowercase, singular (e.g., `auth`, `user`)
- API files: camelCase with "Api" suffix (e.g., `authApi.ts`)
- Service files: camelCase with "Service" suffix (e.g., `authService.ts`)
- Store files: camelCase with "Store" suffix (e.g., `authStore.ts`)
- Components: PascalCase (e.g., `LoginForm.vue`)
- Views: PascalCase with "View" suffix (e.g., `LoginView.vue`)
- Composables: camelCase with "use" prefix (e.g., `useAuth.ts`)
- Utils: camelCase (e.g., `formatDate.ts`)

## Testing Standards

### Unit Tests
- Every function must have unit tests
- Test pure functions thoroughly
- Mock external dependencies (API calls, stores)
- Test edge cases and error scenarios
- Use descriptive test names: `describe('functionName', () => { it('should do X when Y', ...) })`

### Frontend Testing
- Test components in isolation
- Test store actions and state changes
- Test service functions with mocked fetch/axios
- Use Vitest for unit tests
- Use Vue Test Utils for component tests

### Backend Testing
- Test service methods with mocked dependencies
- Test controllers with mocked services
- Use Jest for unit tests
- Use Supertest for integration tests

## Code Review Checklist

Before submitting code, ensure:
- [ ] All functions are pure (or clearly documented if not)
- [ ] Unit tests written with 80%+ coverage
- [ ] Frontend follows 3-layer architecture (UI → Store → Service)
- [ ] Components are small and focused
- [ ] No direct API calls from components
- [ ] No business logic in components
- [ ] TypeScript types are properly defined
- [ ] Code is self-documenting
- [ ] Error handling is implemented
- [ ] No console.logs in production code

## Examples

### ❌ BAD - Component calling API directly
```vue
<script setup>
import { authApi } from '@/modules/auth/api/authApi'

onMounted(async () => {
  await authApi.login() // WRONG!
})
</script>
```

### ❌ BAD - Component calling store async action
```vue
<script setup>
import { useAuthStore } from '@/modules/auth/stores/authStore'

const authStore = useAuthStore()
onMounted(async () => {
  await authStore.login() // WRONG! Stores should not have async actions
})
</script>
```

### ✅ GOOD - Component using service (Module-Based)
```vue
<script setup>
import { authService } from '@/modules/auth/services/authService'

onMounted(async () => {
  await authService.login(credentials) // Service handles async + store updates
})
</script>
```

### ❌ BAD - Store with async operations
```typescript
// modules/auth/stores/authStore.ts
import { authApi } from '../api/authApi'

export const useAuthStore = defineStore('auth', () => {
  async function login(credentials: LoginRequest) { // WRONG! No async in stores
    const result = await authApi.login(credentials)
    // ...
  }
})
```

### ✅ GOOD - Store with sync actions only
```typescript
// modules/auth/stores/authStore.ts
export const useAuthStore = defineStore('auth', () => {
  const user = ref<User | null>(null)
  const loading = ref(false)

  // Sync actions only
  function setUser(newUser: User | null): void {
    user.value = newUser
  }

  function setLoading(isLoading: boolean): void {
    loading.value = isLoading
  }

  return { user, loading, setUser, setLoading }
})
```

### ✅ GOOD - Service handles async and updates store
```typescript
// modules/auth/services/authService.ts
import { authApi } from '../api/authApi'
import { useAuthStore } from '../stores/authStore'

class AuthService {
  private store = useAuthStore()

  async login(credentials: LoginRequest): Promise<void> {
    this.store.setLoading(true)
    try {
      const result = await authApi.login(credentials) // Call API
      this.store.setUser(result.user) // Update store (sync)
    } finally {
      this.store.setLoading(false) // Update store (sync)
    }
  }
}

export const authService = new AuthService()
```

### ❌ BAD - Not using module structure
```
src/
├── services/
│   └── authService.ts
├── stores/
│   └── authStore.ts
└── components/
    └── LoginForm.vue
```

### ✅ GOOD - Module-based structure
```
src/
└── modules/
    └── auth/
        ├── api/
        │   └── authApi.ts
        ├── stores/
        │   └── authStore.ts
        └── components/
            └── LoginForm.vue
```

## Enforcement

These rules are MANDATORY. When writing or reviewing code:
1. Always organize code by modules (not by technical layers)
2. Always check layer separation within modules
3. Always verify test coverage (80%+)
4. Always ensure pure functions where possible
5. Always split large components
6. Always follow the data flow: Component/View → Service → API Layer → Backend → Service → Store (sync) → State
7. Always create modules with proper structure: api/, services/, stores/, views/, components/
8. Always use module-based structure on both frontend and backend
9. **Stores MUST only have synchronous actions** - no async/await in stores
10. **Services MUST handle all async operations** - services call API and update store
11. **Services MUST be instantiated with store** - `new Service(store)` or `private store = useStore()`

